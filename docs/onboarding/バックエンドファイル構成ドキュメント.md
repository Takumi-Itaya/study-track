# バックエンド（Spring Boot）ファイル構成ドキュメント

## 1. なぜこの構成にするのか

このバックエンド構成は、以下の目的を満たすために採用している。

1. **責務の分離（関心の分離 / Separation of Concerns）**

   - Controller：HTTP リクエスト/レスポンスの処理に専念
   - Service：ビジネスロジックに専念
   - Repository：DB アクセスに専念
   - Domain / DTO / Mapper / Exception / Config なども役割を明確化  
     → どのコードをどこに置くか迷いにくく、レビューもしやすい。

2. **変更に強くするため（保守性・拡張性）**

   - 画面仕様・API 仕様が変わっても、Domain・Repository への影響を最小限にできる。
   - DB スキーマ変更・認証方式の変更（セッション →JWT）などの「横断的な変更」も、影響範囲を特定しやすい。
   - Study Track のように、機能が徐々に増えていくサービスでも破綻しにくい。

3. **テストしやすくするため**

   - Controller は「入出力のテスト」、Service は「ビジネスロジックのテスト」と役割を分けられる。
   - Repository は DB をモックにしたテストと実 DB を使った結合テストを分けやすい。
     → 単体テスト・結合テストのレイヤーを整理しやすい。

4. **チーム開発で迷子にならないため**

   - 「新しい API を追加したい」というとき、  
     `controller → service → domain/repository → dto/mapper` の流れで自然に作業が進められる。
   - 途中から参加したメンバーでも、フォルダ構成を見ればおおよその設計思想がわかる。
   - レビュー時にも「このロジックは service に移しましょう」といった共通言語ができる。

5. **将来的なドメイン分割に対応しやすくするため**
   - 初期はレイヤー単位のパッケージ構成（controller / service / repository ...）でシンプルに。
   - 規模が大きくなったら、`user/`, `study/` などのドメイン単位のフォルダに発展させやすい構成にしている。

---

## 2. フォルダごとの意味の詳細

### 2.1 全体構成（例）

```text
backend/
 ├ src/
 │  ├ main/
 │  │  ├ java/
 │  │  │   └ com/example/studytrack/
 │  │  │        ├ config/
 │  │  │        ├ controller/
 │  │  │        ├ service/
 │  │  │        ├ repository/
 │  │  │        ├ domain/
 │  │  │        ├ dto/
 │  │  │        ├ mapper/
 │  │  │        ├ exception/
 │  │  │        └ util/
 │  │  └ resources/
 │  │       ├ application.yml
 │  │       ├ static/
 │  │       ├ templates/
 │  │       └ db/
 │  │            └ migration/   # Flyway など
 │  └ test/
 │      └ java/
 │           └ com/example/studytrack/
 │                ├ controller/
 │                ├ service/
 │                └ repository/
 ├ build.gradle（または pom.xml）
 └ README.md
```

以下、主要フォルダの役割を説明する。

---

### 2.2 config/（設定・共通コンフィグ）

**役割：** <br>
アプリケーション全体に関わる設定クラスを置く場所。

**具体例：**

- Spring Security の設定（JWT 認証・認可の設定）
- CORS 設定
- メッセージソース（国際化）設定
- 共通的な Bean 定義（オブジェクトマッパー、パスワードエンコーダ など）
  **ポイント：**
- 「アプリケーションの振る舞いを変える設定」はここに集約する。
- 設定内容によっては security/, swagger/ などサブパッケージに分けてもよい。

---

### 2.3 controller/（プレゼンテーション層 / WebAPI の入口）

**役割：** <br>
HTTP リクエストを受け取り、Service を呼び出し、DTO でレスポンスを返す。

**責務：**

- URL・HTTP メソッド・パラメータのマッピング
- Request DTO の受け取り・バリデーション（@Valid）
- Response DTO への変換（基本は Service から返ってきた DTO をそのまま返す）
- HTTP ステータスコードの決定（201 Created, 400 Bad Request, 404 Not Found など）

**やらないこと：**

- ビジネスロジックを書く
- DB へ直接アクセスする
- 複雑な条件分岐・計算

---

### 2.4 service/（ビジネスロジック層）

**役割：** <br>
ユースケース（業務処理）をまとめる中心のレイヤー。

**責務：**

- ドメインオブジェクトを使ったビジネスロジックの実装
- 複数の Repository を組み合わせた処理
- トランザクション制御（@Transactional）
- DTO と Domain の橋渡し（Mapper を使用）

**ポイント：**

- Controller から呼び出される「1 API あたり 1 メソッド」を意識すると分かりやすい。
- 「1 ユースケース = 1 Service メソッド」というイメージで設計すると責務が明確になる。

---

### 2.5 repository/（永続化層 / DB アクセス）

**役割：** <br>
DB とのやりとり（CRUD）を担う。

**具体例：**

- Spring Data JPA の interface XxxRepository extends JpaRepository<...>
- 複雑な検索クエリメソッド
- MyBatis を使う場合は Mapper インターフェースと XML を扱うパッケージとしても利用

**ポイント：**

- Service は Repository の「インターフェース」を通じて DB にアクセスする。
- 「DB の実装詳細」を隠蔽し、後から RDB → NoSQL やキャッシュ導入などを行いやすくする。

---

### 2.6 domain/（ドメインモデル / Entity / Value Object）

**役割：** <br>
サービスの「ビジネス上の概念」を表現する。

**具体例：**

- JPA Entity クラス（例：User, StudyRecord など）
- Value Object（メールアドレス、期間、ステータス など）
- ドメインサービス（ビジネスルールを実装するクラス）

**ポイント：**

- DB のテーブル構造に強く依存させすぎず、「業務として意味のあるまとまり」を意識する。
- 将来的に domain/user, domain/study のようにサブパッケージ化し、ドメインごとの境界をはっきりさせていく。

---

### 2.7 dto/（Data Transfer Object：入出力用クラス）

**役割：** <br>
API でやりとりするデータ形式を定義する。

**種類：**

- Request DTO：クライアントからの入力値を受け取る（UserCreateRequest, LoginRequest など）
- Response DTO：クライアントに返す値を表現する（UserResponse, StudySummaryResponse など）

**ポイント：**

- Entity をそのまま JSON レスポンスとして返さず、必ず DTO を経由する。
- バリデーション（@NotBlank, @Email など）は DTO 側に付けることが多い。
- API 仕様の変更は DTO に閉じ込め、Domain / Entity への影響を小さくする。

---

### 2.8 mapper/（DTO ↔ Domain/Entity 変換）

**役割：** <br>
DTO と Domain/Entity を相互変換するクラスを集約する。

**具体例：**

- UserMapper：UserCreateRequest → User、User → UserResponse
- MapStruct を利用するインターフェース定義など

**ポイント：**

- 変換ロジックを Service にベタ書きすると肥大化するので、専用レイヤーに切り出す。
- MapStruct などを使うことで、手書きの変換コードを減らし、バグを防ぐ。

---

### 2.9 exception/（例外クラス・例外ハンドリング）

**役割：**

- 業務エラー用のカスタム例外クラスを定義する。
- @RestControllerAdvice によるグローバル例外ハンドリングをまとめる。

**具体例：**

- NotFoundException, BusinessException, UnauthorizedException など
- GlobalExceptionHandler（例外種類ごとに HTTP ステータスとエラーレスポンスを制御）

**ポイント：**

- エラーレスポンス形式（例：{ code, message, details }）を統一する場所。
- Controller や Service からは「例外を投げる」だけにしておき、レスポンス組み立てはここで行う。

---

### 2.10 util/（共通ユーティリティ）

**役割：** <br>
特定のドメインに属さない共通的な処理をまとめる。

**例：**

- 日付/時刻ユーティリティ
- 文字列フォーマット
- トークン生成のヘルパー（ただし、ドメインと密なものは domain 側に置くことも検討する）

**ポイント：**

- 「なんでも util に入れる」アンチパターンに注意。
- 本当に汎用的か、別レイヤー（domain / service）に置くべきかを都度検討する。

---

### 2.11 `resources`/ 配下

`application.yml` / `application-\*.yml`

- アプリケーション設定（ポート番号、DB 接続、ログレベル、JWT シークレットなど）。
- 環境ごとに application-dev.yml, application-prod.yml などを用意する。

`static/`

- 静的ファイル（画像、CSS、JS など）を配置する場所。
- API サーバーだけの場合は基本的には使用しない。

`templates/`

- Thymeleaf などのテンプレートエンジンを使う場合に HTML を配置。
- SPA + API 構成（Next.js + Spring Boot API）では基本未使用。

---

### 2.12 test/ 配下

**役割：** <br>
テストコードを配置する。

**構成例：**

```text
src/test/java/com/example/studytrack/
 ├ controller/   # API のテスト（MockMvc 等）
 ├ service/      # ビジネスロジックの単体テスト
 └ repository/   # Repository / DB のテスト
```

**ポイント：**

- `main` 側と同じパッケージ構成にすることで、テスト対象クラスを見つけやすくする。
- 単体テストと結合テストを意識して分類する。

---

### 3. 補足：将来的なドメイン単位構成への発展

サービスが大きくなってきた場合、以下のように「ドメイン単位」でフォルダを切る構成に発展させることも可能：

```text
com/example/studytrack/
 ├ user/
 │   ├ controller/
 │   ├ service/
 │   ├ repository/
 │   ├ domain/
 │   ├ dto/
 │   └ mapper/
 ├ study/
 │   ├ controller/
 │   ├ service/
 │   ├ repository/
 │   ├ domain/
 │   ├ dto/
 │   └ mapper/
 ├ config/
 ├ exception/
 └ util/
```

このドキュメントで定義したレイヤーごとの責務を守っておくことで、
後からこのようなドメイン単位構成に移行しやすくなる。
